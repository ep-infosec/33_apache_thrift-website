---
title: "Concepts"
isdoc: true
---

## Thrift network stack
Simple representation of the Apache Thrift networking stack
<pre><code>
  +-------------------------------------------+
  | Server                                    |
  | (single-threaded, event-driven etc)       |
  +-------------------------------------------+
  | Processor                                 |
  | (compiler generated)                      |
  +-------------------------------------------+
  | Protocol                                  |
  | (JSON, compact etc)                       |
  +-------------------------------------------+
  | Transport                                 |
  | (raw TCP, HTTP etc)                       |
  +-------------------------------------------+
</code></pre>

## Transport
The Transport layer provides a simple abstraction for reading/writing from/to the network. This enables Thrift to decouple the underlying transport from the rest of the system (serialization/deserialization, for instance).

Here are some of the methods exposed by the **Transport** interface:

* open
* close
* read
* write
* flush

In addition to the **Transport** interface above, Thrift also uses a **ServerTransport** interface used to accept or create primitive transport objects. As the name suggest, **ServerTransport** is used mainly on the server side to create new  Transport objects for incoming connections.

* open
* listen
* accept
* close

Here are some of the transports available for majority of the Thrift-supported languages:

* file: read/write to/from a file on disk
* http: as the name suggests

## Protocol

The Protocol abstraction defines a mechanism to map in-memory data structures to a wire-format. In other words, a protocol specifies how datatypes use the
underlying Transport to encode/decode themselves.  Thus the protocol implementation governs the encoding scheme and is responsible for (de)serialization. Some examples of protocols in this sense include JSON, XML, plain text, compact binary etc.

Here is the **Protocol** interface:

<pre><code class="language-cpp">
writeMessageBegin(name, type, seq)
writeMessageEnd()
writeStructBegin(name)
writeStructEnd()
writeFieldBegin(name, type, id)
writeFieldEnd()
writeFieldStop()
writeMapBegin(ktype, vtype, size)
writeMapEnd()
writeListBegin(etype, size)
writeListEnd()
writeSetBegin(etype, size)
writeSetEnd()
writeBool(bool)
writeByte(byte)
writeI16(i16)
writeI32(i32)
writeI64(i64)
writeDouble(double)
writeString(string)

name, type, seq = readMessageBegin()
                  readMessageEnd()
name = readStructBegin()
       readStructEnd()
name, type, id = readFieldBegin()
                 readFieldEnd()
k, v, size = readMapBegin()
             readMapEnd()
etype, size = readListBegin()
              readListEnd()
etype, size = readSetBegin()
              readSetEnd()
bool = readBool()
byte = readByte()
i16 = readI16()
i32 = readI32()
i64 = readI64()
double = readDouble()
string = readString()
</code></pre>

Thrift Protocols are stream oriented by design. There is no need for any explicit framing. For instance, it is not necessary to know the length of a
string or the number of items in a list before we start serializing them. Some of the protocols available for majority of the Thrift-supported
languages are:

* binary: Fairly simple binary encoding -- the length and type of a field are encoded as bytes followed by the actual value of the field.
* compact: Described in [THRIFT-110](https://issues.apache.org/jira/browse/THRIFT-110)
* json

## Processor
A Processor encapsulates the ability to read data from input streams and write to output streams. The input and output streams are represented by Protocol
objects. The Processor interface is extremely simple

<pre><code class="language-java">
interface TProcessor {
    bool process(TProtocol in, TProtocol out) throws TException
}
</code></pre>

Service-specific processor implementations are generated by the compiler. The Processor essentially reads data from the wire (using the input protocol),
delegates processing to the handler (implemented by the user) and writes the response over the wire (using the output protocol).

## Server
A Server pulls together all of the various features described above:

* Create a transport
* Create input/output protocols for the transport
* Create a processor based on the input/output protocols
* Wait for incoming connections and hand them off to the processor
